# 函数式编程

1.  函数式编程 FP
2.  编程思想： 函数式/面向过程/面向对象

**函数式编程：** 中的函数指的不是程序中的函数（方法）， _而是数学中的函数 即对应关系_。
_相同的输入始终得到相同的输出（纯函数概念）_
_函数式编程用来描述数据（函数）之间的映射关系_

## 函数式

#### JS 中函数是一等公民

1.  函数可以存在变量中
2.  函数可以作为参数
3.  函数作为返回值

#### 高阶函数

1.  可以把函数作为另一个函数的参数
2.  可以把函数作为另一个函数的返回值

#### 闭包

1. 函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包， 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域的成员
2. 本质： 函数在执行的时候会放到一个执行栈上当函数执行完毕后会从执行栈上移除， **但是堆上的作用域成员因为被外部引用不能释放**， 因此内部函数依然可以访问外部函数的成员。

#### 纯函数

1.  相同的输入永远会得到相同的输出，而且没有副作用 （类似数学中函数的关系， 用来描述输入的输出的关系 如：y=2x）

#### 优势：

1.  可缓存 memoize
2.  可测试（更方便测试, 单元测试其实就断言这个函数的结果）
3.  方便并行处理（web worker）

#### 副作用

1.  如果函数依赖于外部状态就无法保证相同的输出，就会产生富足用
2.  副作用无法完全禁止，尽可能的控制他们在可控的范围内。

#### 函数柯里化

1.  将多元函数转化成一元函数（元： 函数参数的个数）
2.  一个柯里化的函数，可以的接受原函数的部分参数，返回一个接收剩余参数的函数。
3.  最大限度的重用函数
4.  柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某个固定参数的新函数
5.  这是一种函数的参数的’缓存‘（闭包）
6.  让函数变得更灵活，让函数的粒度变得更小
7.  可以把多元函数转化成一元函数，可以组合使用函数产生强大的功能。

```js
// 函数柯里化的实现
const curry = (func) => {
  return function curried(...args) {
    if (args.length < func.length) {
      return () => {
        return curried(...args.concat(Array.from(arguments)));
      };
    }
    return func(...args);
  };
};
```

#### 函数组合

1.  函数组合（compose）：如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
    ~~2. 函数组合默认是从右到左执行的 compose(f1,f2,f3) f3->f2->f1~~
    loash 中 flow()和 flowRight()
2.  模拟实现 flowRight()

```js
const compose = (...args) => (value) => args.reverse().reduce((acc, cur) => cur(acc), value);
```

3. 函数结合律， 复合数学结合律。compose(f1,f2,f3) = compose(compose(f1,f2),f3) = compose(f1,compose(f2,f3))

#### lodash/fp 模块

1.  lodash 的 fp 模块提供了实用的对**函数式编程友好**的方法
2.  提供了不可变 auto-curried iteratee-first data-last 的方法 （fp 模块的函数 式柯里化的 且 函数优先，数据滞后）

```js
const fp = require("lodash/fp");
const arr = ["NEVER", "GIVE", "UP"];
const fn = fp.flowRight(fp.join("-"), fp.map(fp.toLower), fp.split(" "));
fn(arr);
// never-give-up
```

#### Point Free （一种编程风格）

1. 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算过程合并到一起，在实用这种模式之前我们需要定义一些辅助的基本运算函数。

#### Functor （函子）

1. 为什么要学函子：函数式编程中如何把副作用控制在可控的范围内，异常处理、异步造作等。
2. 什么吃 Functor：

   - 容器： 包含值和值的变形关系（这个关系就式函数）

   - 函子： 是一个特殊的容器，通过一个普通的对象来实现，该对象具有 map 方法，map 方法可以运行一个函数对值进行处理（变形关系）

```js
class Container {
  static of(value) {
    return new Container(value);
  }
  constructor(value) {
    this._value = value;
  }
  map(fn) {
    return Container.of(fn(this._value));
  }
}

let r = Container.of(5)
  .map((x) => x + 2)
  .map((x) => x * x);
// 值始终在对象内，通过关系函数 改变。
console.log(r);
```

总结：

- 函数式编程的运算不直接操作值，而是由函子来完成
- 函子就是一个实现了 map 契约的对象
- 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
- 想要处理盒子中的值，我们需要给盒子的 map 方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
- 最终 map 方法返回一个包含新值的盒子（函子）

##### MayBe 函子

- 对外部空值情况做处理（控制副作用在允许范围内） （不会暴露问题所在）

#### Either 函子

- Either 两者中的任何一个，类似于 if...else...的处理 （Left, Right 函子）
- 异常会让函数变得不纯，处理异常的函子

#### IO 函子

- IO 函子中的 \_value 是一个函数，这里是把函数作为值来处理。
- IO 函子可以把不纯的动作储存到\_value 中，延迟执行这个不纯的操作（惰性执行），包装当前的操作
- 把不纯的操作交给调用这来处理。

#### Folktale 一个函数式编程库

#### Task 函子

#### Pointed 函子

#### IO 函子问题

#### Monad 函子

#### 总结
