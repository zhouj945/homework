# 函数式编程

1.  函数式编程 FP
2.  编程思想： 函数式/面向过程/面向对象

**函数式编程：** 中的函数指的不是程序中的函数（方法）， _而是数学中的函数 即对应关系_。
_相同的输入始终得到相同的输出（纯函数概念）_
_函数式编程用来描述数据（函数）之间的映射关系_

## 函数式

#### JS 中函数是一等公民

1.  函数可以存在变量中
2.  函数可以作为参数
3.  函数作为返回值

#### 高阶函数

1.  可以把函数作为另一个函数的参数
2.  可以把函数作为另一个函数的返回值

#### 闭包

1. 函数和其周围的状态（词法环境）的引用捆绑在一起形成闭包， 可以在另一个作用域中调用一个函数的内部函数并访问到该函数的作用域的成员
2. 本质： 函数在执行的时候会放到一个执行栈上当函数执行完毕后会从执行栈上移除， **但是堆上的作用域成员因为被外部引用不能释放**， 因此内部函数依然可以访问外部函数的成员。

#### 纯函数

1.  相同的输入永远会得到相同的输出，而且没有副作用 （类似数学中函数的关系， 用来描述输入的输出的关系 如：y=2x）

#### 优势：

1.  可缓存 memoize
2.  可测试（更方便测试, 单元测试其实就断言这个函数的结果）
3.  方便并行处理（web worker）

#### 副作用

1.  如果函数依赖于外部状态就无法保证相同的输出，就会产生富足用
2.  副作用无法完全禁止，尽可能的控制他们在可控的范围内。

#### 函数柯里化

1.  将多元函数转化成一元函数（元： 函数参数的个数）
2.  一个柯里化的函数，可以的接受原函数的部分参数，返回一个接收剩余参数的函数。
3.  最大限度的重用函数
4.  柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某个固定参数的新函数
5.  这是一种函数的参数的’缓存‘（闭包）
6.  让函数变得更灵活，让函数的粒度变得更小
7.  可以把多元函数转化成一元函数，可以组合使用函数产生强大的功能。

```js
// 函数柯里化的实现
const curry = (func) => {
  return function curried(...args) {
    if (args.length < func.length) {
      return () => {
        return curried(...args.concat(Array.from(arguments)));
      };
    }
    return func(...args);
  };
};
```
